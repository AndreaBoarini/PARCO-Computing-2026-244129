#!/bin/bash
#PBS -N mpi_spmv_simulation
#PBS -j oe
#PBS -o results.out
#PBS -q short_cpuQ
#PBS -l select=4:ncpus=96:mpiprocs=32
#PBS -l walltime=00:14:59
#PBS -l place=scatter:excl

module load mpich-3.2.1--gcc-9.1.0

cd PARCO-Computing-2026-244129/MPI/ || exit 1

MPI_BIND="-bind-to core"
WEAK_DIR="data/synthetic_matrix_weak_scaling"
STRONG_DIR="data/real_matrix"

OUTDIR="results"
LOGDIR="${OUTDIR}/logs"
mkdir -p "$OUTDIR" "$LOGDIR"

WEAK_OUTPUT="$OUTDIR/weak_test_v2.csv"
STRONG_OUTPUT="$OUTDIR/strong_test_v2.csv"

echo "matrix_name,rows,procs,computation_time,communication_time,max_vol,min_vol,avg_vol,max_load,min_load,avg_load,max_mem_KB,min_mem_KB,avg_mem_KB" > "$WEAK_OUTPUT"
echo "matrix_name,rows,procs,computation_time,communication_time,max_vol,min_vol,avg_vol,max_load,min_load,avg_load,max_mem_KB,min_mem_KB,avg_mem_KB" > "$STRONG_OUTPUT"

NPS=(1 2 4 8 16 32 64 128)

get_rows() { awk '!/^%/ {print $1; exit}' "$1"; }

extract_csv_line() {
    local log="$1"
    mapfile -t v < <(grep -v '^[[:space:]]*$' "$log" | tail -n 11)
    local line="${v[0]}"
    for i in {1..10}; do
        line="${line},${v[i]}"
    done
    echo "$line"
}

HOSTS_FILE="${OUTDIR}/pbs_hosts.txt"
sort -u "$PBS_NODEFILE" > "$HOSTS_FILE"
NNODES=$(wc -l < "$HOSTS_FILE")

print_node_arch() {
    mpiexec -f "$HOSTS_FILE" -n "$NNODES" -ppn 1 -l bash -lc '
        echo "--- HOST=$(hostname) ---"
        command -v lscpu >/dev/null 2>&1 && lscpu | egrep "Model name|Socket\\(s\\)|Core\\(s\\) per socket|Thread\\(s\\) per core|CPU\\(s\\)|NUMA node\\(s\\)"
        command -v numactl >/dev/null 2>&1 && numactl -H | sed -n "1,120p"
        command -v hwloc-ls >/dev/null 2>&1 && hwloc-ls --no-io
    '
}

print_rank_mapping() {
    local procs="$1"
    local ppn="$2"
    local map_by="$3"
    mpiexec -f "$HOSTS_FILE" -n "$procs" -ppn "$ppn" $map_by $MPI_BIND -l bash -lc '
        echo "host=$(hostname)"
        if command -v taskset >/dev/null 2>&1; then
            taskset -pc $$
        else
            grep Cpus_allowed_list /proc/self/status
        fi
    '
}

single_run() {
    local procs=$1
    local path=$2
    local out_file=$3

    local base="$(basename "$path")"
    local rows="$(get_rows "$path")"

    local NNODES
    NNODES=$(sort -u "$PBS_NODEFILE" | wc -l)

    local ppn=$(((procs + NNODES - 1) / NNODES))
    if [ "$ppn" -lt 1 ]; then ppn=1; fi
    # Non superare mpiprocs per nodo richiesti a PBS (qui 32)
    if [ "$ppn" -gt 32 ]; then ppn=32; fi

    # Se NUMA Ã¨ supportato come oggetto, usa mapping NUMA-aware
    local map_by="-map-by numa"

    local log="${LOGDIR}/${base}_p${procs}.log"

    {
        echo "===== JOB ALLOCATION ====="
        echo "NNODES=$NNODES"
        echo "NODES:"
        cat "$HOSTS_FILE"

        echo "===== NODE ARCH / NUMA ====="
        print_node_arch

        echo "===== RANK MAPPING (mpiexec -l + taskset) ====="
        echo "np=$procs ppn=$ppn map=$map_by bind=$MPI_BIND"
        print_rank_mapping "$procs" "$ppn" "$map_by"

        echo "===== RUN ====="
        mpiexec -f "$HOSTS_FILE" -n "$procs" -ppn "$ppn" $map_by $MPI_BIND ./main "$path"
    } > "$log" 2>&1

    local csv_line="$(extract_csv_line "$log")"
    echo "${base},${rows},${procs},${csv_line}" >> "$out_file"
}

mpicc -O3 -Iinclude src/main.c src/mmio.c src/csr.c src/ghost.c -o main

# weak scaling
mapfile -t WEAK_MATRICES < <(find "$WEAK_DIR" -maxdepth 1 -type f -name '*.mtx' | sort -V)
for i in "${!NPS[@]}"; do
    single_run "${NPS[i]}" "${WEAK_MATRICES[i]}" "$WEAK_OUTPUT"
done

echo "weak scaling completed..."

# strong scaling
mapfile -t STRONG_MATRICES < <(find "$STRONG_DIR" -maxdepth 1 -type f -name '*.mtx' | sort -V)
for matrix in "${STRONG_MATRICES[@]}"; do
    for procs in "${NPS[@]}"; do
        single_run "$procs" "$matrix" "$STRONG_OUTPUT"
    done
done

echo "strong scaling completed..."
exit 0
